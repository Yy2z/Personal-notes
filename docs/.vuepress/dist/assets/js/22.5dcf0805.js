(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{541:function(v,_,e){"use strict";e.r(_);var t=e(4),i=Object(t.a)({},function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"_1-git简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-git简介","aria-hidden":"true"}},[v._v("#")]),v._v(" 1. git简介")]),v._v(" "),e("p",[v._v("git的通用操作流程如下图")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/25/162fcc0987bf1c0a~tplv-t2oaga2asx-watermark.awebp",alt:"git操作通用流程"}})]),v._v(" "),e("p",[v._v("主要涉及到四个关键点：")]),v._v(" "),e("ol",[e("li",[v._v("工作区：本地电脑存放项目文件的地方，比如learnGitProject文件夹；")]),v._v(" "),e("li",[v._v("暂存区（Index/Stage）：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；")]),v._v(" "),e("li",[v._v("本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；")]),v._v(" "),e("li",[v._v("远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；")])]),v._v(" "),e("p",[v._v("更细节的来看：")]),v._v(" "),e("p",[e("img",{attrs:{src:"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/25/162fcc0e7e711dc7~tplv-t2oaga2asx-watermark.awebp",alt:"git几个核心区域间的关系"}})]),v._v(" "),e("p",[v._v("日常开发时代码实际上放置在工作区中，也就是本地的XXX.java这些文件，通过add等这些命令将代码文教提交给暂存区（Index/Stage），也就意味着代码全权交给了git进行管理，之后通过commit等命令将暂存区提交给master分支上，也就是意味打了一个版本，也可以说代码提交到了本地仓库中。另外，团队协作过程中自然而然还涉及到与远程仓库的交互。")]),v._v(" "),e("p",[v._v("因此，经过这样的分析，git命令可以分为这样的逻辑进行理解和记忆：")]),v._v(" "),e("ol",[e("li",[e("p",[v._v("git管理配置的命令；")]),v._v(" "),e("p",[e("strong",[v._v("几个核心存储区的交互命令：")])])]),v._v(" "),e("li",[e("p",[v._v("工作区与暂存区的交互；")])]),v._v(" "),e("li",[e("p",[v._v("暂存区与本地仓库（分支）上的交互；")])]),v._v(" "),e("li",[e("p",[v._v("本地仓库与远程仓库的交互。")])])]),v._v(" "),e("h1",{attrs:{id:"_2-git配置命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-git配置命令","aria-hidden":"true"}},[v._v("#")]),v._v(" 2. git配置命令")]),v._v(" "),e("blockquote",[e("p",[v._v("查询配置信息")])]),v._v(" "),e("ol",[e("li",[v._v("列出当前配置："),e("code",[v._v("git config --list")]),v._v(";")]),v._v(" "),e("li",[v._v("列出repository配置："),e("code",[v._v("git config --local --list")]),v._v(";")]),v._v(" "),e("li",[v._v("列出全局配置："),e("code",[v._v("git config --global --list")]),v._v(";")]),v._v(" "),e("li",[v._v("列出系统配置："),e("code",[v._v("git config --system --list")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("第一次使用git，配置用户信息")])]),v._v(" "),e("ol",[e("li",[v._v("配置用户名："),e("code",[v._v('git config --global user.name "your name"')]),v._v(";")]),v._v(" "),e("li",[v._v("配置用户邮箱："),e("code",[v._v('git config --global user.email "youremail@github.com"')]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("其他配置")])]),v._v(" "),e("ol",[e("li",[v._v("配置解决冲突时使用哪种差异分析工具，比如要使用vimdiff："),e("code",[v._v("git config --global merge.tool vimdiff")]),v._v(";")]),v._v(" "),e("li",[v._v("配置git命令输出为彩色的："),e("code",[v._v("git config --global color.ui auto")]),v._v(";")]),v._v(" "),e("li",[v._v("配置git使用的文本编辑器："),e("code",[v._v("git config --global core.editor vi")]),v._v(";")])]),v._v(" "),e("h1",{attrs:{id:"_3-工作区上的操作命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-工作区上的操作命令","aria-hidden":"true"}},[v._v("#")]),v._v(" 3. 工作区上的操作命令")]),v._v(" "),e("blockquote",[e("p",[v._v("新建仓库")])]),v._v(" "),e("ol",[e("li",[v._v("将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库："),e("code",[v._v("git init")]),v._v("；")]),v._v(" "),e("li",[v._v("从远程git仓库复制项目："),e("code",[v._v("git clone <url>")]),v._v("，如：git clone git://github.com/wasd/example.git;克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名："),e("code",[v._v("git clone git://github.com/wasd/example.git mygit")]),v._v("；")])]),v._v(" "),e("blockquote",[e("p",[v._v("提交")])]),v._v(" "),e("ol",[e("li",[v._v("提交工作区所有文件到暂存区："),e("code",[v._v("git add .")])]),v._v(" "),e("li",[v._v("提交工作区中指定文件到暂存区："),e("code",[v._v("git add <file1> <file2> ...")]),v._v(";")]),v._v(" "),e("li",[v._v("提交工作区中某个文件夹中所有文件到暂存区："),e("code",[v._v("git add [dir]")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("撤销")])]),v._v(" "),e("ol",[e("li",[v._v("删除工作区文件，并且也从暂存区删除对应文件的记录："),e("code",[v._v("git rm <file1> <file2>")]),v._v(";")]),v._v(" "),e("li",[v._v("从暂存区中删除文件，但是工作区依然还有该文件:"),e("code",[v._v("git rm --cached <file>")]),v._v(";")]),v._v(" "),e("li",[v._v("取消暂存区已经暂存的文件："),e("code",[v._v("git reset HEAD <file>...")]),v._v(";")]),v._v(" "),e("li",[v._v("撤销上一次对文件的操作："),e("code",[v._v("git checkout --<file>")]),v._v("。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理；")]),v._v(" "),e("li",[v._v("隐藏当前变更，以便能够切换分支："),e("code",[v._v("git stash")]),v._v("；")]),v._v(" "),e("li",[v._v("查看当前所有的储藏："),e("code",[v._v("git stash list")]),v._v("；")]),v._v(" "),e("li",[v._v("应用最新的储藏："),e("code",[v._v("git stash apply")]),v._v("，如果想应用更早的储藏："),e("code",[v._v("git stash apply stash@{2}")]),v._v("；重新应用被暂存的变更，需要加上"),e("code",[v._v("--index")]),v._v("参数："),e("code",[v._v("git stash apply --index")]),v._v(";")]),v._v(" "),e("li",[v._v("使用apply命令只是应用储藏，而内容仍然还在栈上，需要移除指定的储藏："),e("code",[v._v("git stash drop stash{0}")]),v._v("；如果使用pop命令不仅可以重新应用储藏，还可以立刻从堆栈中清除："),e("code",[v._v("git stash pop")]),v._v(";")]),v._v(" "),e("li",[v._v("在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果："),e("code",[v._v("git stash show -p stash@{0} | git apply -R")]),v._v("；同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏："),e("code",[v._v("git stash show -p | git apply -R")]),v._v("；")])]),v._v(" "),e("blockquote",[e("p",[v._v("更新文件")])]),v._v(" "),e("ol",[e("li",[v._v("重命名文件，并将已改名文件提交到暂存区："),e("code",[v._v("git mv [file-original] [file-renamed]")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("查新信息")])]),v._v(" "),e("ol",[e("li",[v._v("查询当前工作区所有文件的状态："),e("code",[v._v("git status")]),v._v(";")]),v._v(" "),e("li",[v._v("比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较："),e("code",[v._v("git diff <file-name>")]),v._v(";")])]),v._v(" "),e("h1",{attrs:{id:"_4-暂存区上的操作命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-暂存区上的操作命令","aria-hidden":"true"}},[v._v("#")]),v._v(" 4. 暂存区上的操作命令")]),v._v(" "),e("blockquote",[e("p",[v._v("提交文件到版本库")])]),v._v(" "),e("ol",[e("li",[v._v("将暂存区中的文件提交到本地仓库中，即打上新版本："),e("code",[v._v('git commit -m "commit_info"')]),v._v(";")]),v._v(" "),e("li",[v._v("将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程："),e("code",[v._v('git commit -a -m "commit_info"')]),v._v(";")]),v._v(" "),e("li",[v._v("提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交："),e("code",[v._v("git commit --amend")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("查看信息")])]),v._v(" "),e("ol",[e("li",[v._v("比较暂存区与上一版本的差异："),e("code",[v._v("git diff --cached")]),v._v(";")]),v._v(" "),e("li",[v._v("指定文件在暂存区和本地仓库的不同："),e("code",[v._v("git diff <file-name> --cached")]),v._v(";")]),v._v(" "),e("li",[v._v("查看提交历史：git log；参数"),e("code",[v._v("-p")]),v._v("展开每次提交的内容差异，用"),e("code",[v._v("-2")]),v._v("显示最近的两次更新，如"),e("code",[v._v("git log -p -2")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("打标签")])]),v._v(" "),e("p",[v._v("Git 使用的标签有两种类型："),e("strong",[v._v("轻量级的（lightweight）和含附注的（annotated）")]),v._v("。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。")]),v._v(" "),e("ol",[e("li",[v._v("列出现在所有的标签："),e("code",[v._v("git tag")]),v._v(";")]),v._v(" "),e("li",[v._v("使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣："),e("code",[v._v('git tag -l "v1.4.2.*"')]),v._v(";")]),v._v(" "),e("li",[v._v("创建一个含附注类型的标签，需要加"),e("code",[v._v("-a")]),v._v("参数，如"),e("code",[v._v('git tag -a v1.4 -m "my version 1.4"')]),v._v(";")]),v._v(" "),e("li",[v._v("使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象："),e("code",[v._v("git show v1.4")]),v._v(";")]),v._v(" "),e("li",[v._v("如果有自己的私钥，可以使用GPG来签署标签，只需要在命令中使用"),e("code",[v._v("-s")]),v._v("参数："),e("code",[v._v('git tag -s v1.5 -m "my signed 1.5 tag"')]),v._v(";")]),v._v(" "),e("li",[v._v("验证已签署的标签：git tag -v ，如"),e("code",[v._v("git tag -v v1.5")]),v._v(";")]),v._v(" "),e("li",[v._v("创建一个轻量级标签的话，就直接使用git tag命令即可，连"),e("code",[v._v("-a")]),v._v(","),e("code",[v._v("-s")]),v._v("以及"),e("code",[v._v("-m")]),v._v("选项都不需要，直接给出标签名字即可，如"),e("code",[v._v("git tag v1.5")]),v._v(";")]),v._v(" "),e("li",[v._v("将标签推送到远程仓库中：git push origin ，如"),e("code",[v._v("git push origin v1.5")]),v._v("；")]),v._v(" "),e("li",[v._v("将本地所有的标签全部推送到远程仓库中："),e("code",[v._v("git push origin --tags")]),v._v(";")])]),v._v(" "),e("blockquote",[e("p",[v._v("分支管理")])]),v._v(" "),e("ol",[e("li",[v._v("创建分支："),e("code",[v._v("git branch <branch-name>")]),v._v("，如"),e("code",[v._v("git branch testing")]),v._v("；")]),v._v(" "),e("li",[v._v("从当前所处的分支切换到其他分支："),e("code",[v._v("git checkout <branch-name>")]),v._v("，如"),e("code",[v._v("git checkout testing")]),v._v("；")]),v._v(" "),e("li",[v._v("新建并切换到新建分支上："),e("code",[v._v("git checkout -b <branch-name>")]),v._v(";")]),v._v(" "),e("li",[v._v("删除分支："),e("code",[v._v("git branch -d <branch-name>")]),v._v("；")]),v._v(" "),e("li",[v._v("将当前分支与指定分支进行合并："),e("code",[v._v("git merge <branch-name>")]),v._v(";")]),v._v(" "),e("li",[v._v("显示本地仓库的所有分支："),e("code",[v._v("git branch")]),v._v(";")]),v._v(" "),e("li",[v._v("查看各个分支最后一个提交对象的信息："),e("code",[v._v("git branch -v")]),v._v(";")]),v._v(" "),e("li",[v._v("查看哪些分支已经合并到当前分支："),e("code",[v._v("git branch --merged")]),v._v(";")]),v._v(" "),e("li",[v._v("查看当前哪些分支还没有合并到当前分支："),e("code",[v._v("git branch --no-merged")]),v._v(";")]),v._v(" "),e("li",[v._v("把远程分支合并到当前分支："),e("code",[v._v("git merge <remote-name>/<branch-name>")]),v._v("，如"),e("code",[v._v("git merge origin/serverfix")]),v._v("；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；")]),v._v(" "),e("li",[v._v("在远程分支的基础上创建新的本地分支"),e("code",[v._v("：git checkout -b <branch-name> <remote-name>/<branch-name>")]),v._v("，如"),e("code",[v._v("git checkout -b serverfix origin/serverfix")]),v._v(";")]),v._v(" "),e("li",[v._v("从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容："),e("code",[v._v("git push")]),v._v("。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支："),e("code",[v._v("git pull")]),v._v("；")]),v._v(" "),e("li",[v._v("将一个分支里提交的改变移到基底分支上重放一遍："),e("code",[v._v("git rebase <rebase-branch> <branch-name>")]),v._v("，如"),e("code",[v._v("git rebase master server")]),v._v("，将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用"),e("code",[v._v("--onto")]),v._v("操作："),e("code",[v._v("git rebase --onto <rebase-branch> <feature branch> <sub-feature-branch>")]),v._v("，如"),e("code",[v._v("git rebase --onto master server client")]),v._v("；使用rebase操作应该遵循的原则是："),e("strong",[v._v("一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作")]),v._v("；")])]),v._v(" "),e("h1",{attrs:{id:"_5-本地仓库上的操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-本地仓库上的操作","aria-hidden":"true"}},[v._v("#")]),v._v(" 5.本地仓库上的操作")]),v._v(" "),e("ol",[e("li",[v._v("查看本地仓库关联的远程仓库："),e("code",[v._v("git remote")]),v._v("；在克隆完每个远程仓库后，远程仓库默认为"),e("code",[v._v("origin")]),v._v(";加上"),e("code",[v._v("-v")]),v._v("的参数后，会显示远程仓库的"),e("code",[v._v("url")]),v._v("地址；")]),v._v(" "),e("li",[v._v("添加远程仓库，一般会取一个简短的别名："),e("code",[v._v("git remote add [remote-name] [url]")]),v._v("，比如："),e("code",[v._v("git remote add example git://github.com/example/example.git")]),v._v(";")]),v._v(" "),e("li",[v._v("从远程仓库中抓取本地仓库中没有的更新："),e("code",[v._v("git fetch [remote-name]")]),v._v("，如"),e("code",[v._v("git fetch origin")]),v._v(";使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用"),e("code",[v._v("git pull")]),v._v("来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；")]),v._v(" "),e("li",[v._v("将本地仓库某分支推送到远程仓库上："),e("code",[v._v("git push [remote-name] [branch-name]")]),v._v("，如"),e("code",[v._v("git push origin master")]),v._v("；如果想将本地分支推送到远程仓库的不同名分支："),e("code",[v._v("git push <remote-name> <local-branch>:<remote-branch>")]),v._v("，如"),e("code",[v._v("git push origin serverfix:awesomebranch")]),v._v(";如果想删除远程分支："),e("code",[v._v("git push [romote-name] :<remote-branch>")]),v._v("，如"),e("code",[v._v("git push origin :serverfix")]),v._v("。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。")]),v._v(" "),e("li",[v._v("查看远程仓库的详细信息："),e("code",[v._v("git remote show origin")]),v._v("；")]),v._v(" "),e("li",[v._v("修改某个远程仓库在本地的简称："),e("code",[v._v("git remote rename [old-name] [new-name]")]),v._v("，如"),e("code",[v._v("git remote rename origin org")]),v._v("；")]),v._v(" "),e("li",[v._v("移除远程仓库："),e("code",[v._v("git remote rm [remote-name]")]),v._v("；")])]),v._v(" "),e("h1",{attrs:{id:"_6-忽略文件-gitignore"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-忽略文件-gitignore","aria-hidden":"true"}},[v._v("#")]),v._v(" 6. 忽略文件.gitignore")]),v._v(" "),e("p",[v._v("一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。如下例：")]),v._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("# 此为注释 – 将被 Git 忽略\n# 忽略所有 .a 结尾的文件\n*.a\n# 但 lib.a 除外\n!lib.a\n# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\n/TODO\n# 忽略 build/ 目录下的所有文件\nbuild/\n# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\ndoc/*.txt\n# 忽略 doc/ 目录下所有扩展名为 txt 的文件\ndoc/**/*.txt\n复制代码\n")])])])])},[],!1,null,null,null);_.default=i.exports}}]);